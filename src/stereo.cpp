// This file is part of cnn-crf-stereo.
//
// Copyright (C) 2017 Christian Reinbacher <reinbacher at icg dot tugraz dot at>
// Institute for Computer Graphics and Vision, Graz University of Technology
// https://www.tugraz.at/institute/icg/teams/team-pock/
//
// dvs-panotracking is free software: you can redistribute it and/or modify it under the
// terms of the GNU Affero General Public License as published by the Free Software
// Foundation, either version 3 of the License, or any later version.
//
// cnn-crf-stereo is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "stereo.h"
#include "stereo.cuh"
#include <iu/iumath.h>
#include "tools.h"
#include <sys/stat.h>
#include <cstdio>
#include <iu/iuio.h>

#include "graystereonet.h"
#include "colorstereonet.h"
#include "concatstereonet.h"

Stereo::Stereo():img1(0),img2(0),costvolume_(0),wx(0),wy(0),out(0),
p(0),matching_function_(CENSUS),solver(0), num_cnn_layers_(3),stereoNet(NULL),verbose_(false)
{
}

Stereo::~Stereo()
{
    delete img1;
    delete img2;
    delete img1_color;
    delete img2_color;
    delete costvolume_;
    delete wx;
    delete wy;
    delete d_pairwiseOut;
    delete out;
    delete out_;
    delete out0;
    delete p;
    delete q;
    delete qf;
    delete out_slack;
    cuda::unprepareFuseTTVL1();

    destroyCNN();
}


int Stereo::log2i(int num){
    int ret = 0;
    while (num >>= 1){
        ++ret;
    };
    return ret;
}

void Stereo::initialize(const iu::Size<2> size, float disp_min, float disp_step, float disp_max)
{
    // cost volume
    width_ = size[0];
    height_ = size[1];

    // break points
    depth_ = (disp_max-disp_min)/disp_step +1 ; // Number of break points
    depth_ = std::min(256,1<<(log2i(depth_-1) +1));
    disp_max_ = disp_min+(depth_-1)*disp_step;

    setDisparityRange(disp_min,disp_step,disp_max_);

    // init memory
    img1 = new iu::ImageGpu_32f_C1(width_,height_);
    img2 = new iu::ImageGpu_32f_C1(width_,height_);
    img1_color = new iu::ImageGpu_32f_C4(width_,height_);
    img2_color = new iu::ImageGpu_32f_C4(width_,height_);
    costvolume_ = new iu::LinearDeviceMemory_32f_C1(depth_*width_*height_);
//    costvolume_ = NULL;
    d_pairwiseOut = new iu::TensorGpu_32f(1, 2, height_, width_, iu::TensorGpu_32f::NCHW);
    wx = new iu::ImageGpu_32f_C1(d_pairwiseOut->data(),width_,height_,width_*sizeof(float),true);
    wy = new iu::ImageGpu_32f_C1(d_pairwiseOut->data(width_*height_),width_,height_,width_*sizeof(float),true);

    out0 = new iu::ImageGpu_32f_C1(width_,height_);
    out = new iu::ImageGpu_32f_C1(width_,height_);
    out_slack = new iu::ImageGpu_32s_C1((int*)out->data(),width_,height_,out->pitch(),true);
    out_ = new iu::ImageGpu_32f_C1(width_,height_);

    qf = new iu::ImageGpu_32f_C2(width_,height_);

    p = new iu::ImageGpu_32f_C2(width_,height_);
    q = new iu::ImageGpu_32f_C2(width_,height_);

    occlusion_mask = new iu::ImageGpu_8u_C1(width_,height_);

    solver = NULL;

    cnn_parameter_file_base_name_ = "params";
    num_cnn_layers_ = 3;
    cuda::prepareFuseTTVL1(out,out_,p,q);
}

void Stereo::setImages(const iu::ImageCpu_32f_C1 &img1, const iu::ImageCpu_32f_C1 &img2)
{
    assert(img1.size() == img2.size());
    assert(img1.size() == this->img1->size());

    iu::copy(&img1, this->img1);
    iu::copy(&img2, this->img2);

}

void Stereo::setColorImages(const iu::ImageCpu_32f_C4 &img1, const iu::ImageCpu_32f_C4 &img2)
{
    assert(img1.size() == img2.size());
    assert(img1.size() == this->img1_color->size());

    iu::copy(&img1, this->img1_color);
    iu::copy(&img2, this->img2_color);
    cuda::rgb2gray(img1_color,this->img1);
    cuda::rgb2gray(img2_color,this->img2);
}


void Stereo::computeSlackPropagation(float C1, float C2, float delta, int iterations, float alpha, float beta, float lambda_reg, bool lr)
{
    computeVolume(lr);
    if(matching_function_!= GRAYCNN_PAIRWISE && matching_function_!= COLORCNN_PAIRWISE && matching_function_!= CONCATCNN_PAIRWISE) // otherwise the weights are generated by the CNN
        computeWeights(alpha,beta,lambda_reg,lr);
    else
    {
    	iu::math::mulC(*wx, lambda_reg, *wx);
		  iu::math::mulC(*wy, lambda_reg, *wy);
    }

    if(!solver) {
        solver = new slack_prop_2D_alg;
        solver->init(ndarray_ref<float,3>(*costvolume_,{depth_,width_,height_}),*out_slack);
    }

    iu::IuCudaTimer cut;
    if (verbose_)
        cut.start();

    solver->ops["L1"] = C1;
    solver->ops["L2"] = C2;
    solver->ops["delta"] = delta;
    solver->ops["total_it"] = iterations;
    solver->update_W(*wx,*wy);
    solver->execute();
    if(lr)
        cuda::remapSolution(out,out_slack,disp_min_,disp_step_,disp_max_);
    else
        cuda::remapSolution(out,out_slack,-disp_max_,disp_step_,-disp_min_);
    if (verbose_)
        std::cout << "Elapsed time CRF: " << cut.elapsed() << std::endl;
    cudaDeviceSynchronize();
}

void Stereo::computeArgMax(bool lr)
{
    computeVolume(lr);
    if(lr) // match from left to right
    {
        cuda::computeArgmin(out,costvolume_,disp_min_,disp_step_);
    }
    else  // match from right to left
    {
        cuda::computeArgmin(out,costvolume_,-disp_max_,disp_step_);
    }

    cudaDeviceSynchronize();
}

void Stereo::computeVolume(bool lr)
{
    // lazyly construct any cnn for matching
	if((matching_function_ == GRAYCNN || matching_function_ == COLORCNN || matching_function_ == CONCATCNN
			|| matching_function_ == GRAYCNN_PAIRWISE || matching_function_ == COLORCNN_PAIRWISE || matching_function_ == CONCATCNN_PAIRWISE)
    		&& stereoNet == NULL)
	{
        std::string params_name;
        // check if we have to append the number of layers to filename
        params_name = cnn_parameter_file_base_name_ + ".npz";
        struct stat buffer;
        if(stat (params_name.c_str(), &buffer) != 0)
        {
            params_name = cnn_parameter_file_base_name_ + std::to_string(num_cnn_layers_) + ".npz";
        }

		// init stereo net (LAZY!)
		if((matching_function_ == GRAYCNN || matching_function_ == COLORCNN) && num_cnn_layers_ != 3 && num_cnn_layers_ != 5 && num_cnn_layers_ != 7)
		{
			std::cout << "Error: Only {3,5,7} Layers are allowed" << std::endl;
			exit(-1);
		}

		switch(num_cnn_layers_) {
			case 3:
                padval=2;
				break;
			case 5:
				padval=3;
				break;
			case 7:
				padval=4;
				break;
			default: // case concatcnn
				padval=0;
				break;
		}

		d_stereoNetMatchingOutput =  new iu::TensorGpu_32f(costvolume_->data(), 1, ((disp_max_ - disp_min_) / disp_step_) + 1,
		                img1->height(), img1->width(), true, iu::TensorGpu_32f::MemoryLayout::NHWC);


		if(matching_function_ == COLORCNN || matching_function_ == CONCATCNN || matching_function_ == COLORCNN_PAIRWISE || matching_function_ == CONCATCNN_PAIRWISE)
		{
			if(padval > 0)
			{
				I1_padded_color = new iu::ImageGpu_32f_C4(img1_color->width() + 2 * padval, img1_color->height() + 2 * padval);
				I2_padded_color = new iu::ImageGpu_32f_C4(img2_color->width() + 2 * padval, img2_color->height() + 2 * padval);
                I2_warped_color = new iu::ImageGpu_32f_C4(img2_color->width(),img2_color->height());
			}
			else
			{
				I1_padded_color = img1_color;
				I2_padded_color = img2_color;
			}

			if(matching_function_ == COLORCNN || matching_function_ == COLORCNN_PAIRWISE)
			{
				int ic = (with_xy == true) ? 5 : 3;
				stereoNet = new ColorStereoNet(num_cnn_layers_, 1, ic, I1_padded_color->height(), I1_padded_color->width());
				if(matching_function_ == COLORCNN)
				{
					stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput);
				}
				else
				{
					stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput, d_pairwiseOut);
				}
                stereoNet->setVerbose(verbose_);
			}
			else if(matching_function_ == CONCATCNN || matching_function_ == CONCATCNN_PAIRWISE)
			{
				stereoNet = new ConcatStereoNet(num_cnn_layers_, 1, 3, I1_padded_color->height(), I1_padded_color->width());
				if(matching_function_ == CONCATCNN)
					stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput);
				else
					stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput, d_pairwiseOut);
			}

			else
			{
				std::cout << "unknown or not implemented matching function" << std::endl;
				exit(-1);
			}

		}
		else if(matching_function_ == GRAYCNN || matching_function_ == GRAYCNN_PAIRWISE)
		{
			if(padval > 0)
			{
				I1_padded = new iu::ImageGpu_32f_C1(img1->width()+2*padval,img1->height()+2*padval);
				I2_padded = new iu::ImageGpu_32f_C1(img1->width()+2*padval,img1->height()+2*padval);
			}
			else
			{
				I1_padded = img1;
				I2_padded = img2;
			}


			stereoNet = new GrayStereoNet(num_cnn_layers_, 1, 1, I1_padded->height(), I1_padded->width());
			if(matching_function_ == GRAYCNN)
			{
                stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput);
			}
			else if(matching_function_ == GRAYCNN_PAIRWISE)
			{
				stereoNet->initNet(disp_min_, disp_max_, disp_step_,rect_corr, d_stereoNetMatchingOutput, d_pairwiseOut);
			}
		}

		// set params to any constructed cnn
        stereoNet->setAllParams(params_name);
        stereoNet->setAllowGc(allowCnnGc);
	}

	// execute matching
    if(lr) // match from left to right
    {
        if(matching_function_ == CENSUS)
        {
            cuda::calccostvolumecensus(this->img1,this->img2,1.f,filter_size_,disp_min_,disp_step_,disp_max_,costvolume_,0);
        }
        else if(matching_function_ == LOAD)
        {
            // do nothing, we have the volume
        }
        else
        {
        	stereoNet->setDisparities(disp_min_,disp_max_, disp_step_, d_stereoNetMatchingOutput);
        	if(matching_function_ == COLORCNN || matching_function_ == CONCATCNN || matching_function_ == COLORCNN_PAIRWISE)
        	{
        		cuda::calccostvolumeColorCNN(img1_color, I1_padded_color, img2_color, I2_padded_color, stereoNet, padval);
        	}
        	else
			{
        		cuda::calccostvolumeCNN(img1, I1_padded, img2, I2_padded, stereoNet, padval);
			}
        }
    }
    else  // match from right to left
    {
        if(matching_function_ == CENSUS)
        {
            cuda::calccostvolumecensus(this->img2,this->img1,1.f,filter_size_,-disp_max_,disp_step_,-disp_min_,costvolume_,0);
        }
        else if(matching_function_ == LOAD)
        {
            // do nothing, we have the volume
        }
        else
        {
        	stereoNet->setDisparities(-disp_max_, -disp_min_, disp_step_, d_stereoNetMatchingOutput);
        	if(matching_function_ == COLORCNN || matching_function_ == CONCATCNN || matching_function_ == COLORCNN_PAIRWISE)
        	{
        		cuda::calccostvolumeColorCNN(img2_color, I2_padded_color, img1_color, I1_padded_color, stereoNet, padval);

        	}
        	else
        	{
        		cuda::calccostvolumeCNN(img2, I2_padded, this->img1, I1_padded, stereoNet, padval);

        	}
        }
    }
    cudaDeviceSynchronize();
}

void Stereo::computeWeights(float alpha, float beta, float lambda, bool lr)
{
    if(lr)
        cuda::calcEdgeImage(img1,out,wx,wy,alpha,beta,lambda);
    else
        cuda::calcEdgeImage(img2,out,wx,wy,alpha,beta,lambda);
}

void Stereo::setMatchingFunction(MatchingFunction function)
{
    matching_function_ = function;
}

void Stereo::destroyCNN(void)
{
	if(stereoNet)
		delete stereoNet;
	stereoNet = NULL;

	if(d_stereoNetMatchingOutput)
		delete d_stereoNetMatchingOutput;
	d_stereoNetMatchingOutput = NULL;

	if(I1_padded)
		delete I1_padded;
	I1_padded = NULL;

	if(I2_padded)
		delete I2_padded;
	I2_padded = NULL;

    //std::cout << __FUNCTION__ << std::endl;
}

void Stereo::setNumLayers(int num_layers)
{
    num_cnn_layers_=num_layers;
    destroyCNN();
}

void Stereo::setParameterFile(std::string base_name)
{
    cnn_parameter_file_base_name_ = base_name;
    destroyCNN();
}

bool Stereo::loadVolumeFromFile(std::string filename)
{
    iu::LinearHostMemory_32f_C1 costvolume_cpu(depth_*width_*height_);
    std::FILE* f=std::fopen(filename.c_str(),"rb");
    if(f) {
        std::fread(costvolume_cpu.data(),sizeof(float),costvolume_cpu.numel(),f);
        std::fclose(f);
        iu::copy(&costvolume_cpu,costvolume_);
        saveMatPython2("test.npy",costvolume_, width_, height_, depth_);
        return true;
    }
    return false;
}

void Stereo::setDisparityRange(float disp_min,float disp_step, float disp_max)
{
    this->disp_min_=disp_min;
    this->disp_step_=disp_step;
    this->disp_max_=disp_max;
}


void Stereo::fuseTHuberQuadFit(float lambda_reg, float C, int iterations, int warps)
{
    if(matching_function_ == COLORCNN || matching_function_ == CONCATCNN || matching_function_ == COLORCNN_PAIRWISE)
        cuda::fuseTHuberQuadFit(out,out_,out0,img1_color,img2_color,I2_warped_color,wx,wy,qf,p,q,I1_padded_color,I2_padded_color,padval,stereoNet,1.f/lambda_reg,C,disp_step_,iterations,warps);
    else
        cuda::fuseTHuberQuadFit(out,out_,out0,img1,img2,do_inpainting?occlusion_mask:NULL,wx,wy,qf,p,q,I1_padded,I2_padded,padval,stereoNet,filter_size_*(matching_function_==CENSUS),1.f/lambda_reg,C,disp_step_,iterations,warps);
}

void Stereo::fuseQuadFitDirect(void)
{
    cuda::fuseQuadFitDirect(out, solver->get_C1().permute_dims({1,2,0}),qf, disp_min_, disp_step_);
}


iu::ImageGpu_32f_C1* Stereo::getOutput()
{
//	cudaStreamSynchronize(stream_fuse);
    cudaDeviceSynchronize();
    return out;
}

iu::LinearDeviceMemory_32f_C1 *Stereo::getVolume()
{
    cudaDeviceSynchronize();
    return costvolume_;
}

iu::ImageGpu_32f_C1 *Stereo::getWx(float alpha, float beta, bool left)
{
    if(alpha>0)
        computeWeights(alpha,beta,1.f,left);
    return wx;
}

iu::ImageGpu_32f_C1 *Stereo::getWy(float alpha, float beta, bool left)
{
    if(alpha>0)
        computeWeights(alpha,beta,1.f,left);
    return wy;
}

iu::ImageGpu_32s_C1 *Stereo::getIntegerOutput()
{
    return out_slack;
}

int Stereo::getDepth() const
{
    return depth_;
}

void Stereo::performLeftRightCheck(iu::ImageGpu_32f_C1* out,
		iu::ImageGpu_32f_C1* left, iu::ImageGpu_32f_C1* right,
        float th)
{
    cuda::leftRightCheck(out,left,right,th);
    cudaDeviceSynchronize();
}

